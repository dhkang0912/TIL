## 백트래킹 응용 & 그래프 (트리)
1. 백트래킹 응용
2. 트리 개요
3. 이진 트리
4. 이진 탐색 트리 (BST)
5. 힙 트리 (Heap)


## 백트래킹
- 완전 탐색 + 가지치기
- 가능성이 없는 (볼 필요 없는) 경우의 수를 제거하는 기법  
<br>
- 중복된 순열
- 1~3까지 숫자 배열이 있을 때
- 111, 112, 113, 121, 122, 123 ... 332, 333  
<br>
- 재귀 함수 => 특정 시점으로 돌아오는게 핵심!
- 재귀 함수 팁
    - 파라미터 : 바로 작성 X, 구조를 먼저 잡으면 자연스럽게 필요한 변수들이 보임

```python
arr = [i for i in range(1, 4)]

def dfs(level):
    # 기저 조건
    # 이 문제에서는 3개를 뽑았을 때까지 반복
    if level == 3:
        return
    # 들어가기 전
    # 다음 재귀 호출
    
    # - 다음에 갈 수 있는 곳들은 어디인가?
    # - 이 문제에서는 1, 2, 3 세가지 (arr의 길이만큼) 경우의 수가 존재
    # 갔다와서 할 로직
    
    # 갈 수 있는 후보군
    for i in range(len(arr)):
        # 여기는 못가! (가지치기)
        # 백트래킹 코드 팁
        # 갈 수 없는 경우를 활용
        # 아래 코드처럼 갈 수 없을 때 continue
        # 조건1 ~~
        if arr[i] in path:
            continue
        
        # 조건 2
        path[level] = arr[i]
        dfs(level + 1)
        
        # 갔다와서 할 로직
        # 기존 방문을 초기화

```

## 트리
- 트리는 싸이클이 없는 무향 연결 그래프이다
    - 두 노드(or 정점) 사이에는 유일한 경로가 존재함
    - 각 노드는 최대 하나의 부모 노드가 존재할 수 있음
    - 각 노드는 자시 노드가 없거나 하나 이상이 존재할 수 있음
- 비선형 구조
    - 원소들 간에 1:n 관계를 가지는 자료 구조
    - 원소들 간에 계층 관계를 가지는 계층형 자료 구조
    
### 트리 정의
- 한 개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족함
    - 노드 중 부모가 없는 노드를 루트라 함
    - 나머지 노드들은 n(>= 0)개의 분리 집합 T1,''',TN으로 분리될 수 있음
    
- 이들 T1,''',TN은 각각 하나의 트리가 되며(재귀적 정의) 루트의 서브 트리라 함

### 트리 용어
- 노드(node) : 트리의 원소이고 정점(vertex)이라고도 함
- 간선(edge) : 노드를 연결하는 선
    - 부모 노드와 자식 노드를 연결
- 루트 노드 : 트리의 시작 노드
- 형제 노드 : 같은 부모 노드의 자식 노드들
- 조상 노드 : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 서브 트리 : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드 : 서브 트리에 있는 하위 레벨의 노드들

### 차수 (degree)
- 노드의 차수 : 노드에 연결된 자식 노드의 수
- 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
- 단말 노드 (리프 노드) : 차수가 0인 노드, 자식 노드가 없는 노드

### 높이
- 노드의 높이 : 루트에서 노드에 이르는 간선의 수, 노드의 레벨
    - B의 높이 = 1, F의 높이 = 2
- 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값, 최대 레벨
    - 트리 T의 높이 = 3
    
### 이진 트리
- 모든 노드들이 최대 2개의 서브 트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리
    - 왼쪽 자식 노드
    - 오른쪽 자식 노드
    
- 노드의 개수가 N개일 때, 이진 트리 높이의 h는 몇이 될까?
    - 최악의 경우 : 높이 h = N
    - 최선의 경우 : 높이 h = logN
    
### 완전 이진 트리
- 높이가 h이고 노드 수가 n개일 때 (단, 2**h <= n <= 2**(h+1)-1), 포화 이진 트리의 노드 번호가 1번부터 n번까지 빈 자리가 없는 이진 트리

### 편향 이진 트리
- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

### 포화 이진 트리
- 순회란 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말하는데 비 선형 구조이기 때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없다
- 따라서 특별한 방법이 필요함

```python
arr = [1, 2, 1, 3, 2, 4, 3, 5, 3, 6, 4, 7, 5, 8, 5, 9, 6, 10, 6, 11, 7, 12, 11, 13]

#정석 개발 버전
class TreeNode :
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

    def insert(self, child):
        #왼쪽에 삽입 시도
        if not self.left :
            self.left = child
            return

        #오른쪽에 삽입 시도
        if not self.right :
            self.right = child
            return

       #삽입 실패
        return

    def inorder(self):
        if self != None :
            #왼쪽이 있으면 계속 탐색
            if self.left :
                self.left.inorder()

            print(self.value, end=' ')

            #오른쪽이 있으면 계속 탐색
            if self.right :
                self.right.inorder()



#이진 트리 만들기
#1. 노드들을 생성
nodes = [TreeNode(i) for i in range(0,14)]

#2. 간선 연결
for i in range(0, len(arr), 2) :
    parent_node = arr[i]
    child_node = arr[i+1]
    nodes[parent_node].insert(nodes[child_node])

nodes[1].inorder()

# 코딩 테스트에서는 간단하게
# 코딩테스트에서는 간단하게
# 키워드 : 인접리스트!
nodes = [[] for _ in range(14)]
for i in range(0, len(arr), 2) :
    parent_node = arr[i]
    child_node = arr[i+1]
    nodes[parent_node].append(child_node)

#자식이 없다는 걸 표시하기 위해 None
for li in nodes:
    for _ in range(len(li), 2):
        li.append(None)


#중위순회 구현
def inorder(nodeNum) :
    #갈 수 없다면 skip
    if nodeNum == None :
        return

    #왼쪽으로 갈 수 있다면 진행
    inorder(nodes[nodeNum][0])
    print(nodeNum, end = ' ')
    #오른쪽으로 갈 수 있다면 진행
    inorder(nodes[nodeNum][1])

inorder(1)
```
    
### 이진탐색트리
- 탐색작업을 효율적으로 하기 위한 자료 구조
- 모든 원소는 서로 다른 유일한 키를 갖음
- key(왼쪽 서브 트리) < key(루트 노드) < key(오른쪽 서브 트리)
- 왼쪽 서브 트리와 오른쪽 서브 트리도 이진 탐색 트리
- 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있음

### 이진탐색 트리의 연산
- 탐색 연산
    - 루트에서 탐색 시작
    - 탐색할 키 값 x를 루트 노드의 키 값 k와 비교
        - x == k : 탐색 성공
        - x < k : 루트 노드의 왼쪽 서브 트리에 대해서 탐색 연산 수행
        - x > k : 루트 노드의 오른쪽 서브 트리에 대해서 탐색 연산 수행
    - 서브 트리에 대해서 순환적으로 탐색 연산을 반복
    - 탐색 수행할 서브 트리가 없으면 탐색 실패
    
- 탐색 연산의 횟수는 트리의 높이



    

    
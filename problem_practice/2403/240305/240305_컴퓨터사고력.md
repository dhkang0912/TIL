<Computational Thinking>
-기초 논리 & 수학-

0. 서론 - 프로그래밍과 논리/수학

1. 논리학
soft logic : 직관적 논리(익숙한 상황에서 빠름, 정확하지 않음)
hard logic : 진짜 논리


이치 : 과정의 순서가 올바르게 연결됨
논리 : 근거와 주장을 잇는 것, 이야기의 이치(이야기의 올바른 연결)
논리학
예시) 농구하는 사람들은 키가 큼
     농구를 하면 키가 커진다 True? False? => False

*중요!
형식 : p이면 q이다.
명제 : True나 False로 판단할 수 있는 문장(개인적인 생각으로 나눠지더라도 명제)

<도전문제>
명제, 참 구분하기
1.T
2.T
3.X 의문문
4.X 명령문
5.F
6.T

부정 : 어떤 주장을 부인(~가 아니다 or ~하지 않다)
주장의 부정 : 주장을 제외한 모든 가능성을 포함

*수업 - 전제 2가지 존재
1.배중률 : True or False 무조건(중간이 없는 것)(예시. 무조건 False는 아니다 -> True)
2.모순율 : True와 False 동시에 성립하지 않는 것(예시. 머리 염색)

*참고
이기다 - 부정 : 이기지 않다
      - 반대 : 지다
나는 친구를 좋아한다 - 부정 : 좋아하지 않는다/좋아하진 않다
                  - 반대 : 싫어한다

<도전문제>
부정하는 문장 만들어보기
1.민철이는 제주도에 간 적이 있진 않다.
2.코코는 뉴욕에 살지 않지는 않는다.?오엥?
3.라면에 마늘을 항상 넣진 않는다.
4.도현이는 지나치게 많이 먹지 않는다.


수식
p -> q
명제 : p, q, r, s...
참/거짓 : T/F
부정 : ~

예시) 한국의 수도는 서울이다      p = T
    한국의 수도는 서울이 아니다  ~p = F

=> 명제 부정하면 참과 거짓이 반전됨

and : A ^ B : 교집합
or : A V B : 합집합
xor: A + B : 합집합 - 교집합

배타적 논리합 xor : p + q : 같으면 False, 다르면 True

1.가정 명제가 거짓이면 전체 명제식은 참이다.
2.대우 명제가 참이면 기존 명제도 참이다.




2. 알고리즘 성능 계산법 _시간복잡도 계산(과목평가에 나올 수 있음)
빅오 표기법으로 풀기
1.T(n) = T(n-1) + 1
  T(0) = 1


T(n-1) = T(n-2) + 1
T(n) = T(n-2) + 1 + 1 = T(n-2) + 2

T(n-2) = T(n-3) + 1
T(n) = T(n-3) + 3 = T(n-k) + k     # k = n 대입
     = T(0) + n
     = n + 1

*O(T(n)) = O(n)

-------------------------------------------------------------------
2.T(n) = T(n-1) + n
  T(0) = 1

T(n-1) = T(n-2) + n-1  # n에 n-1 대입
T(n) = T(n-2) + (n-1) + n

T(n-2) = T(n-3) + (n-2) + (n-1) + n
T(n) = T(n-k) + (n-(k-1)) + ... + n      # T(0)만들기 위해 k = n 대입
     = T(0) + 1 + ... + n
     = 1 + n(n+1)/2

*O(T(n)) = O(n^2) #상수 배수 뺌

-------------------------------------------------------------------
3.T(n) = T(n-1) + logn
  T(0) = 1

T(n-1) = T(n-2) + log(n-1)       # n에 n-1 대입
T(n) = T(n-2) + log(n-1) + logn  # 만약 n이 크다면 -1 무시 가능
     <= T(n-2) + nlogn
     <= T(n-k) + nlogn           # k = n
     <= T(0) + nlogn = nlogn + 1

*O(T(n)) = O(nlogn)

-------------------------------------------------------------------
4.T(n) = T(n/2) + 1
  T(1) = 1

T(n/2) = T(n/2^2) + 1
T(n) =  T(n/2^2) + 2

T(n/2^2) = T(n/2^3) + 1
T(n) = T(n/2^3) + 3 = T(n/2^k) + k    # 2^k = n -> logn = k
     = T(1) + logn
     = logn + 1

*O(T(n)) = O(logn)